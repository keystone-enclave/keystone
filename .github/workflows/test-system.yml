
on:
  workflow_call:

jobs:
  test-generic:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: [generic]
        bits: [32, 64]

    steps:
    # We don't need submodules here since Keystone is a monorepo!
    - name: Checkout Keystone
      uses: actions/checkout@v3
      with:
        submodules: 'false'

    - name: Restore build directory
      uses: actions/download-artifact@v4
      with:
        name: keystone-${{ matrix.platform }}${{ matrix.bits }}-builddir
        path: .

    - name: Decompress build directory
      run: cat build.tar.xz | xz -d -T0 | tar -xf -

    - name: Test Keystone system
      run: |
        # Fix permissions on the key
        chmod 600 build-${{ matrix.platform }}${{ matrix.bits }}/buildroot.build/target/root/.ssh/id-rsa

        # Launch QEMU
        export KEYSTONE_PLATFORM=${{ matrix.platform }}
        export KEYSTONE_BITS=${{ matrix.bits }}
        export LD_LIBRARY_PATH=build-${{ matrix.platform }}${{ matrix.bits }}/buildroot.build/host/lib
        screen -L -dmS qemu bash -c "make run 2>&1 | tee run.log"

        # TODO: check for connectivity instead of sleeping
        sleep 20

        export CALL_LOGFILE=cmd.log
        echo "" > $CALL_LOGFILE

        KEYSTONE_COMMAND="modprobe keystone-driver" make call
        KEYSTONE_COMMAND="/usr/share/keystone/examples/tests.ke" make call
        KEYSTONE_COMMAND="/usr/share/keystone/examples/attestor.ke" make call
        KEYSTONE_COMMAND="poweroff" make call

    - name: Check expected
      run: |
        [[ -z $(diff cmd.log scripts/ci/expected.log) ]]

    - name: Upload run log
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-keystone-${{ matrix.platform }}${{ matrix.bits }}-run.log
        path: run.log

    - name: Upload cmd log
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-keystone-${{ matrix.platform }}${{ matrix.bits }}-cmd.log
        path: cmd.log

  test-mpfs:
    runs-on: [self-hosted, mpfs]
    environment: track
    steps:
    # We don't need submodules here since Keystone is a monorepo!
    - name: Checkout Keystone
      uses: actions/checkout@v3
      with:
        submodules: 'false'

    - name: Restore build directory
      uses: actions/download-artifact@v4
      with:
        name: keystone-mpfs64-builddir
        path: .

    - name: Decompress build directory
      run: cat build.tar.xz | xz -d -T0 | tar -xf -

    # Test the firmware, first by flashing it
    - name: Flash HSS
      env:
        POWER_ON_CMD: ${{ vars.POWER_ON_CMD_MPFS }}
        POWER_OFF_CMD: ${{ vars.POWER_OFF_CMD_MPFS }}
        SC_INSTALL_DIR: ${{ vars.SC_INSTALL_DIR }}
      run: |
        $POWER_ON_CMD
        export FPGENPROG=$(which fpgenprog)
        make -C build-mpfs64/buildroot.build/build/hss-v2023.06 program 2>/dev/null >program.log
        $POWER_OFF_CMD

        # Check if we succeeded
        [[ ! -z $(cat program.log | grep "mpfsBootmodeProgrammer completed successfully") ]]

    # And then verifying that we can actually get to the command line
    - name: Check HSS ok
      env:
        POWER_ON_CMD: ${{ vars.POWER_ON_CMD_MPFS }}
        POWER_OFF_CMD: ${{ vars.POWER_OFF_CMD_MPFS }}
      run: |
        # Collect serial output
        screen -L -dmS mpfs-tty bash -c "stty raw -echo 115200 < /dev/ttyUSB0 ; cat /dev/ttyUSB0 > run-hss.log"
        $POWER_ON_CMD ; sleep 30 ; $POWER_OFF_CMD
        screen -XS mpfs-tty quit

        # At least the first hart should have started
        [[ ! -z $(cat run-hss.log | sed -e 's/\x1b\[[0-9;]*m//g' | grep "u54 State Change:  \[Running\]") ]]

    - name: Upload HSS run log
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-keystone-mpfs64-run-hss.log
        path: run-hss.log

    # Now we also need to flash the disk. First, get into usbdmsc
    - name: Flash OS
      env:
        POWER_ON_CMD: ${{ vars.POWER_ON_CMD_MPFS }}
        POWER_OFF_CMD: ${{ vars.POWER_OFF_CMD_MPFS }}
      run: |
        # Wait for the board to come up a bit. We'll hammer it with serial
        # input to ensure that we halt the boot at HSS
        $POWER_ON_CMD
        NOW=$(date +%s)
        stty raw -echo 115200 < /dev/ttyUSB0
        while [[ $(( $(date +%s) - $NOW )) -lt 10 ]]; do echo 'a' > /dev/ttyUSB0 ; done

        echo "" > /dev/ttyUSB0
        echo "usbdmsc" > /dev/ttyUSB0

        # Wait a bit for the USB to connect then flash
        sleep 10
        dd if=build-mpfs64/buildroot.build/images/sdcard.img of=/dev/sda bs=4M oflag=direct
        sync
        $POWER_OFF_CMD

    - name: Test Keystone system
      env:
        POWER_ON_CMD: ${{ vars.POWER_ON_CMD_MPFS }}
        POWER_OFF_CMD: ${{ vars.POWER_OFF_CMD_MPFS }}
        KEYSTONE_IP: ${{ vars.BOARD_IP_MPFS }}
      run: |
        # Fix permissions on the key
        chmod 600 build-mpfs64/buildroot.build/target/root/.ssh/id-rsa

        # Start the board
        export KEYSTONE_PLATFORM=mpfs
        export KEYSTONE_BITS=64
        screen -L -dmS mpfs-tty bash -c "stty raw -echo 115200 < /dev/ttyUSB1 ; cat /dev/ttyUSB1 > run.log"
        $POWER_ON_CMD

        # TODO: check for connectivity instead of sleeping
        sleep 30

        export CALL_LOGFILE=cmd.log
        echo "" > $CALL_LOGFILE

        KEYSTONE_COMMAND="modprobe keystone-driver" make call
        KEYSTONE_COMMAND="/usr/share/keystone/examples/tests.ke" make call
        KEYSTONE_COMMAND="/usr/share/keystone/examples/attestor.ke" make call

        $POWER_OFF_CMD
        screen -XS mpfs-tty quit
